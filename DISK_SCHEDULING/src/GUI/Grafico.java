/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package GUI;


import SCHEDULING.CSCAN;
import SCHEDULING.FIFO;
import SCHEDULING.NSCAN;
import SCHEDULING.RANDOM;
import SCHEDULING.SCAN;
import SCHEDULING.SSTF;
import UTIL.Control;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.util.Arrays;
import java.util.LinkedList;
import javax.swing.BorderFactory;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.block.BlockBorder;
import org.jfree.chart.event.ChartChangeListener;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.chart.title.TextTitle;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;
import org.jfree.ui.RectangleInsets;


/**
 *
 * @author Erin
 */
public class Grafico extends javax.swing.JFrame{

    /**
     * Creates new form Grafico
     */
    public Grafico() {
        initUI();
        initComponents();
    }
    
//     public Grafico(String algoritmo) {
//        initComponents();
//    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 545, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 417, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(32, 32, 32)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(76, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(46, 46, 46)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(66, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void initUI() {
                          
        XYDataset dataset = createDataset();
        JFreeChart chart = createChart(dataset);
        ChartPanel chartPanel = new ChartPanel(chart);
        chartPanel.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));
        chartPanel.setBackground(Color.white);
        add(chartPanel);


        pack();
        setTitle("Disk scheduling");
        setLocationRelativeTo(null);
        //setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
    
   
    private XYDataset createDataset() {
       
        //XYSeries series = new XYSeries("Secuencia de pistas visitadas");
        XYSeries series1 = new XYSeries("C-SCAN");
        XYSeries series2 = new XYSeries("FIFO");
        XYSeries series3 = new XYSeries("LIFO");
        XYSeries series4 = new XYSeries("F-SCAN");
        XYSeries series5 = new XYSeries("N-SCAN");
        XYSeries series6 = new XYSeries("PRIORIDAD");
        XYSeries series7 = new XYSeries("RANDOM");
        XYSeries series8 = new XYSeries("SCAN");
        XYSeries series9 = new XYSeries("SSTF");
        XYSeries series10 = new XYSeries("FIFOPRI");
        XYSeries series11 = new XYSeries("LIFOPRI");
        
        Integer[] CSCAN = Control.cscanTracks.toArray(new Integer[Control.cscanTracks.size()]);
        Integer[] FIFO = Control.fifoTracks.toArray(new Integer[Control.fifoTracks.size()]);
        Integer[] LIFO = Control.lifoTracks.toArray(new Integer[Control.lifoTracks.size()]);
        Integer[] FSCAN = Control.fscanTracks.toArray(new Integer[Control.fscanTracks.size()]);
        Integer[] NSCAN = Control.nscanTracks.toArray(new Integer[Control.nscanTracks.size()]);
        Integer[] PRI = Control.prioridadTracksEstadisticas.toArray(new Integer[Control.prioridadTracksEstadisticas.size()]);
        Integer[] RAM = Control.randomTracks.toArray(new Integer[Control.randomTracks.size()]);
        Integer[] SCAN = Control.scanTracks.toArray(new Integer[Control.scanTracks.size()]);
        Integer[] SSTF = Control.sstfTracks.toArray(new Integer[Control.sstfTracks.size()]);
        Integer[] FIFOPRI = Control.fifoPriTracksEstadisticas.toArray(new Integer[Control.fifoPriTracksEstadisticas.size()]);
        Integer[] LIFOPRI = Control.lifoPriTracksEstadisticas.toArray(new Integer[Control.lifoPriTracksEstadisticas.size()]);
        
        Integer[] DisCSCAN = Control.cscanDistancias.toArray(new Integer[Control.cscanDistancias.size()]);
        System.out.println(Arrays.toString(DisCSCAN));
        Integer[] DisFIFO = Control.fifoDistancias.toArray(new Integer[Control.fifoDistancias.size()]);
        Integer[] DisLIFO = Control.lifoDistancias.toArray(new Integer[Control.lifoDistancias.size()]);
        Integer[] DisFSCAN = Control.fscanDistancias.toArray(new Integer[Control.fscanDistancias.size()]);
        Integer[] DisNSCAN = Control.nscanDistancias.toArray(new Integer[Control.nscanTracks.size()]);
        Integer[] DisPRI = Control.prioridadDistancias.toArray(new Integer[Control.prioridadDistancias.size()]);
        Integer[] DisRAM = Control.randomDistancias.toArray(new Integer[Control.randomDistancias.size()]);
        Integer[] DisSCAN = Control.scanDistancias.toArray(new Integer[Control.scanDistancias.size()]);
        Integer[] DisSSTF = Control.sstfDistancias.toArray(new Integer[Control.sstfDistancias.size()]);
        Integer[] DisFIFOPRI = Control.fifoPriDistancias.toArray(new Integer[Control.fifoPriDistancias.size()]);
        Integer[] DisLIFOPRI = Control.lifoPriDistancias.toArray(new Integer[Control.lifoPriDistancias.size()]);
      
        series1.clear();
        series2.clear();
        series3.clear();
        series4.clear();
        series5.clear();
        series6.clear();
        series7.clear();
        series8.clear();
        series9.clear();
        series10.clear();
        series11.clear();
        
        /*for (Integer array1 : CSCAN) {
            for (Integer arraydis1 : DisCSCAN)
            series1.add(arraydis1, array1);
        }*/
        series1.add((Integer) 0, CSCAN[0]);
        for (int i = 0; i < DisCSCAN.length; i++){
            series1.add(DisCSCAN[i], CSCAN[i+1]);
        }
        
        series2.add((Integer) 0, FIFO[0]);
        for (int i =0; i < DisFIFO.length; i++) {
            series2.add(DisFIFO[i], FIFO[i+1]);  
        }
        
        series3.add((Integer) 0, LIFO[0]);
        for (int i =0; i < DisLIFO.length; i++) {
            series3.add(DisLIFO[i], LIFO[i+1]);  
        }
       
        series4.add((Integer) 0, FSCAN[0]);
        for (int i =0; i < DisFSCAN.length; i++) {
            series4.add(DisFSCAN[i], FSCAN[i+1]);  
        }
        
        series5.add((Integer) 0, NSCAN[0]);
        for (int i =0; i < DisNSCAN.length; i++) {
            series5.add(DisNSCAN[i], NSCAN[i+1]);  
        }
        
        series6.add((Integer) 0, PRI[0]);
        for (int i =0; i < DisPRI.length; i++) {
            series6.add(DisPRI[i], PRI[i+1]);  
        }
      
        series7.add((Integer) 0, RAM[0]);
        for (int i =0; i < DisRAM.length; i++) {
            series7.add(DisRAM[i], RAM[i+1]);  
        }
       
        series8.add((Integer) 0, SCAN[0]);
        for (int i =0; i < DisSCAN.length; i++) {
            series8.add(DisSCAN[i], SCAN[i+1]);  
        }

        series9.add((Integer) 0, SSTF[0]);
        for (int i =0; i < DisSSTF.length; i++) {
            series9.add(DisSSTF[i], SSTF[i+1]);  
        }

        series10.add((Integer) 0, FIFOPRI[0]);
        for (int i =0; i < DisFIFOPRI.length; i++) {
            series10.add(DisFIFOPRI[i], FIFOPRI[i+1]);  
        }
        
        series11.add((Integer) 0, LIFOPRI[0]);
        for (int i =0; i < DisLIFOPRI.length; i++) {
            series11.add(DisLIFOPRI[i], LIFOPRI[i+1]);  
        }
       
       
        XYSeriesCollection dataset = new XYSeriesCollection();
        //dataset.addSeries(series);
        dataset.addSeries(series1);
        dataset.addSeries(series2);
        dataset.addSeries(series3);
        dataset.addSeries(series4);
        dataset.addSeries(series5);
        dataset.addSeries(series6);
        dataset.addSeries(series7);
        dataset.addSeries(series8);
        dataset.addSeries(series9);
        dataset.addSeries(series10);
        dataset.addSeries(series11);

        return dataset;
    }
    

    private JFreeChart createChart(XYDataset dataset) {

        JFreeChart chart = ChartFactory.createXYLineChart(
                "Disk scheduling", 
                "Time", 
                "Track nnumber", 
                dataset, 
                PlotOrientation.VERTICAL,
                true, 
                true, 
                false 
        );
        
        chart.getXYPlot().setDataset(chart.getXYPlot().getDataset());
        XYPlot plot = chart.getXYPlot();
        
    
        XYLineAndShapeRenderer renderer = new XYLineAndShapeRenderer();
        renderer.setSeriesPaint(0, Color.RED);
        renderer.setSeriesStroke(0, new BasicStroke(2.0f));
        
        // sets paint color for plot outlines
      
        plot.setOutlinePaint(Color.BLACK);
        plot.setOutlineStroke(new BasicStroke(2.0f));


        plot.setRenderer(renderer);
        plot.setBackgroundPaint(Color.white);

        plot.setRangeGridlinesVisible(true);
        plot.setRangeGridlinePaint(Color.BLACK);

        plot.setDomainGridlinesVisible(true);
        plot.setDomainGridlinePaint(Color.BLACK);

        chart.getLegend().setFrame(BlockBorder.NONE);

        chart.setTitle(new TextTitle("Disk Scheduling Algorithms",
                        new Font("Serif", java.awt.Font.BOLD, 18)));
       
             
        return chart;
        
       
       

    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
                
     
        
        
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
               // Control.leerArchivo();
                new Grafico().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel jPanel1;
    // End of variables declaration//GEN-END:variables
}
